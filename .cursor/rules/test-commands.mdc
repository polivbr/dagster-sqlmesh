---
description: Test commands for dg-sqlmesh module
alwaysApply: false
---

# Test Commands for dg-sqlmesh

## Make Commands

Always use the [Makefile](mdc:Makefile) for testing tasks:

```bash
# Basic testing
make test                    # Run all tests
make test-core              # Run core component tests
make test-integration       # Run integration tests
make test-coverage          # Run tests with coverage report

# Specific test files
make test-factory           # Test factory functions
make test-resource          # Test SQLMeshResource
make test-translator        # Test SQLMeshTranslator
make test-console           # Test event console

# Development testing
make test-watch             # Run tests in watch mode
make test-debug             # Run tests with debug output
make test-verbose           # Run tests with verbose output
```

## Manual Test Commands

### SQLMesh Integration Testing

```bash
# Test SQLMesh project setup
uv run --group dev sqlmesh -p tests/sqlmesh_project plan --no-prompts

# Test SQLMesh execution
uv run --group dev sqlmesh -p tests/sqlmesh_project run --no-prompts

# Test SQLMesh with specific models
uv run --group dev sqlmesh -p tests/sqlmesh_project run --models stg_customers,stg_orders --no-prompts

# Test SQLMesh audits
uv run --group dev sqlmesh -p tests/sqlmesh_project run --models customers --no-prompts
```

### Dagster Integration Testing

```bash
# Test Dagster definitions creation
uv run --group dev python -c "
from dg_sqlmesh import sqlmesh_definitions_factory
defs = sqlmesh_definitions_factory(project_dir='tests/sqlmesh_project', gateway='duckdb')
print(f'Created {len(defs.assets)} assets')
print(f'Created {len(defs.resources)} resources')
print(f'Created {len(defs.jobs)} jobs')
"

# Test individual asset creation
uv run --group dev python -c "
from dg_sqlmesh import sqlmesh_assets_factory, SQLMeshResource
resource = SQLMeshResource(project_dir='tests/sqlmesh_project', gateway='duckdb')
assets = sqlmesh_assets_factory(sqlmesh_resource=resource)
print(f'Created {len(assets)} individual assets')
for asset in assets:
    print(f'- {asset.key}')
"
```

### Event Console Testing

```bash
# Test event capture
uv run --group dev python -c "
from dg_sqlmesh.sqlmesh_event_console import SQLMeshEventCaptureConsole
console = SQLMeshEventCaptureConsole()
print('Event console created successfully')
print(f'Failed events: {len(console.get_failed_models_events())}')
print(f'Skipped events: {len(console.get_skipped_models_events())}')
print(f'Evaluation events: {len(console.get_evaluation_events())}')
"
```

## Test Data Management

### Load Test Data

```bash
# Load Jaffle Shop data
uv run --group dev python tests/load_jaffle_data.py

# Verify data loading
uv run --group dev python -c "
import duckdb
conn = duckdb.connect('tests/sqlmesh_project/jaffle_test.db')
print('Customers:', conn.execute('SELECT COUNT(*) FROM main.raw_source_customers').fetchone()[0])
print('Orders:', conn.execute('SELECT COUNT(*) FROM main.raw_source_orders').fetchone()[0])
print('Items:', conn.execute('SELECT COUNT(*) FROM main.raw_source_items').fetchone()[0])
"
```

### Clean Test Data

```bash
# Clean test database
rm -f tests/sqlmesh_project/jaffle_test.db

# Recreate test environment
uv run --group dev sqlmesh -p tests/sqlmesh_project plan dev --no-prompts
uv run --group dev sqlmesh -p tests/sqlmesh_project invalidate dev
```

## Individual Asset Testing

### Test Asset Creation

```bash
# Test individual asset creation
uv run --group dev python -c "
from dg_sqlmesh import sqlmesh_assets_factory, SQLMeshResource
resource = SQLMeshResource(project_dir='tests/sqlmesh_project', gateway='duckdb')
assets = sqlmesh_assets_factory(sqlmesh_resource=resource)

# Verify individual assets
for asset in assets:
    print(f'Asset: {asset.key}')
    print(f'  Group: {asset.group_name}')
    print(f'  Checks: {len(asset.check_specs) if asset.check_specs else 0}')
    print(f'  Tags: {asset.tags}')
    print()
"
```

### Test Shared Execution

```bash
# Test SQLMeshResultsResource
uv run --group dev python -c "
from dg_sqlmesh.factory import SQLMeshResultsResource
resource = SQLMeshResultsResource()

# Test results storage
resource.store_results('test_run', {'data': 'test'})
print('Results stored:', resource.has_results('test_run'))

# Test results retrieval
results = resource.get_results('test_run')
print('Results retrieved:', results)

# Test non-existent run
print('Non-existent run:', resource.has_results('non_existent'))
"
```

## Run materialization with command line

```bash
# in the folder of your dagster project
uv run dg launch --assets "jaffle_db/sqlmesh_jaffle_platform/stg_tweets"
# run materialization for all sqlmesh assets using search string like in the UI
uv run dg asset materialize --select 'kind:"sqlmesh" and tag:"sqlmesh"'
```

## Integration Testing

### Test Complete Integration

```bash
# Test complete integration
uv run --group dev python -c "
from dg_sqlmesh import sqlmesh_definitions_factory
defs = sqlmesh_definitions_factory(
    project_dir='tests/sqlmesh_project',
    gateway='duckdb',
    enable_schedule=False
)

print('=== Integration Test Results ===')
print(f'Assets created: {len(defs.assets)}')
print(f'Resources configured: {list(defs.resources.keys())}')
print(f'Jobs created: {list(defs.jobs.keys())}')

# Verify SQLMeshResultsResource is included
assert 'sqlmesh_results' in defs.resources, 'SQLMeshResultsResource not found'
print('✅ SQLMeshResultsResource configured')

# Verify no retry tags
for asset in defs.assets:
    assert asset.tags.get('dagster/max_retries') == '0', f'Asset {asset.key} missing max_retries tag'
    assert asset.tags.get('dagster/retry_on_asset_or_op_failure') == 'false', f'Asset {asset.key} missing retry_on_asset_or_op_failure tag'
print('✅ No retry tags configured')
"
```

### Test External Assets

```bash
# Test external asset handling
uv run --group dev python -c "
from dg_sqlmesh.translator import SQLMeshTranslator
translator = SQLMeshTranslator()

# Test external asset key mapping
external_key = translator.get_external_asset_key('\"main\".\"external\".\"customers\"')
print('External asset key:', external_key)

# Test tag convention
class MockModel:
    def __init__(self, tags):
        self.tags = tags

model = MockModel({
    'dagster:group_name:custom_group',
    'dagster:owner:data_team',
    'production'
})

group_name = translator._get_dagster_property_from_tags(model, 'group_name')
owner = translator._get_dagster_property_from_tags(model, 'owner')
print(f'Group name from tag: {group_name}')
print(f'Owner from tag: {owner}')
"
```

## Error Handling Testing

### Test No Retry Policy

```bash
# Test no retry policy
uv run --group dev python -c "
from dg_sqlmesh import sqlmesh_assets_factory, SQLMeshResource
resource = SQLMeshResource(project_dir='tests/sqlmesh_project', gateway='duckdb')
assets = sqlmesh_assets_factory(sqlmesh_resource=resource)

# Verify no retry tags
for asset in assets:
    assert asset.tags.get('dagster/max_retries') == '0', f'Asset {asset.key} missing max_retries tag'
    assert asset.tags.get('dagster/retry_on_asset_or_op_failure') == 'false', f'Asset {asset.key} missing retry_on_asset_or_op_failure tag'

print('✅ All assets have no retry tags configured')
"
```

### Test Exception Handling

```bash
# Test SQLMesh exception handling
uv run --group dev python -c "
from dg_sqlmesh import SQLMeshResource
from sqlmesh.core.errors import CircuitBreakerError, PlanError

resource = SQLMeshResource(project_dir='tests/sqlmesh_project', gateway='duckdb')

try:
    # This might fail depending on environment
    resource.plan()
    print('✅ Plan executed successfully')
except (CircuitBreakerError, PlanError) as e:
    print(f'✅ SQLMesh exception handled: {type(e).__name__}')
except Exception as e:
    print(f'⚠️ Unexpected exception: {type(e).__name__}: {e}')
"
```

## Performance Testing

### Test Execution Performance

```bash
# Test SQLMesh execution performance
uv run --group dev python -c "
import time
from dg_sqlmesh import SQLMeshResource

resource = SQLMeshResource(project_dir='tests/sqlmesh_project', gateway='duckdb')

# Measure execution time
start_time = time.time()
try:
    resource.plan()
    execution_time = time.time() - start_time
    print(f'SQLMesh plan execution time: {execution_time:.2f} seconds')

    if execution_time < 30:
        print('✅ Execution time is reasonable')
    else:
        print('⚠️ Execution time is slow')
except Exception as e:
    print(f'❌ Execution failed: {e}')
"
```

## Coverage Testing

### Run Coverage Report

```bash
# Generate coverage report
PYTHONPATH=src uv run --group dev pytest tests/ --cov=dg_sqlmesh --cov-report=html --cov-report=term

# View coverage in browser
open htmlcov/index.html
```

### Coverage Analysis

```bash
# Analyze coverage by module
uv run --group dev python -c "
import coverage
cov = coverage.Coverage()
cov.load()
print('Coverage by module:')
for filename in cov.get_data().measured_files():
    if 'dg_sqlmesh' in filename:
        percent = cov.analysis2(filename)[1]
        print(f'{filename}: {percent:.1f}%')
"
```

## Debug Testing

### Debug Asset Creation

```bash
# Debug asset creation with verbose logging
uv run --group dev python -c "
import logging
logging.basicConfig(level=logging.DEBUG)

from dg_sqlmesh import sqlmesh_assets_factory, SQLMeshResource
resource = SQLMeshResource(project_dir='tests/sqlmesh_project', gateway='duckdb')
assets = sqlmesh_assets_factory(sqlmesh_resource=resource)

print(f'Created {len(assets)} assets with debug logging')
"
```

### Debug Event Capture

```bash
# Debug event capture
uv run --group dev python -c "
import logging
logging.basicConfig(level=logging.DEBUG)

from dg_sqlmesh.sqlmesh_event_console import SQLMeshEventCaptureConsole
console = SQLMeshEventCaptureConsole()

print('Event console created with debug logging')
print(f'Event handlers: {len(console._handlers)}')
"
```
